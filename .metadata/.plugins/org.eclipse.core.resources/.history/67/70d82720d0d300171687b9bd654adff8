/*
 * Créé par David Ringuet
 * 
 */

import java.io.*;
import java.text.*;

public class MainExercisesTableaux {	
	private static final int NB_EXERCISES = 10;
	private static boolean quitter = false;
	
	
	public static void main(String[] args) throws IOException {
		int choix;
		
		do {
			
			choix = afficherMenuPrincipal(NB_EXERCISES);
			
			switch (choix) {
			case 1:
				
				int valACompter, requrenceVal , nbElements = lireEntier("\nEntrez le nombre d'éléments du" + 
											" tableau : "), borneInferieure = lireEntier("\nEntrez la borne inférieure du" + 
											" tableau : "), borneSupperieure = lireEntier("\nEntrez la borne suppérieure du" + 
															" tableau : ");
				
				int[] tabAleatoire = new int[nbElements] ;
				tabAleatoire = genererTabEntier(nbElements, borneInferieure, borneSupperieure);
				
				String titreTableau = "\n" + lireChaine("Entrez le titre du tableau à afficher : ");
				
				afficherTabEntier(titreTableau,tabAleatoire);
				valACompter = lireEntier("Entrer une le chiffre que vous désirez compter le récqurrence : ");
				requrenceVal = compterValTabEntier(tabAleatoire, valACompter);
				System.out.println("la valeur " + valACompter + " apparais " + requrenceVal + " fois dans le tableau");
				break;
			case 2:
				int prodTableau;
				nbElements = lireEntier("\nEntrez le nombre d'éléments du" + 
						" tableau : ");
				borneInferieure = lireEntier("\nEntrez la borne inférieure " +
						"suppérieure à 0 (zéro) du tableau : ");
				while(borneInferieure <= 0){
					borneInferieure = lireEntier("\nValeur entré n'est pas " +
							"suppérieur à zéro.\nEntrez la borne inférieure " +
							"suppérieure à 0 (zéro) du tableau : ");
				}
				borneSupperieure = lireEntier("\nEntrez la borne suppérieure du" + 
										" tableau : ");
				
				int[] tabEntiers = new int[nbElements] ;
				tabEntiers = genererTabEntier(nbElements, borneInferieure, borneSupperieure);
				prodTableau = calculerProduitTabEntier(tabEntiers);
				System.out.println("\nle produit du tableau est : " + prodTableau);
				break;
			case 3:
				int[] tabResultatsVotes, tabVotes;
				
				int nbCandidats = lireEntierSuppZero("\nEntrez le nombre de candidats : ");
				
				tabVotes = genererTabVotes(nbCandidats);
				tabResultatsVotes = compterVotes(tabVotes, nbCandidats);
				afficherTabEntier("Tableau des votes", tabVotes);
				afficherTabEntier("Tableau des résultats", tabResultatsVotes);
				break;
			case 4:
				
				break;
			case 5:
				
				break;
			case 6:
				break;
			case 7:
				break;
			case 8:
				break;
			case 9:
				break;
			case 10:
				break;
			case 0:
				quitter = true;
				break;
			default:
				System.out.println("Choix invalide " + choix);
			}
			lireEntree("\nappuyez sur la touche entrée pour continuer");	
		}while (!quitter);
		System.out.println("\n Fin du programme");
	}
	private static int[] genererTabVotes(int nbCandidats) throws IOException{
		final int NB_CANDIDATS_MIN = 1;
		int nbElements= lireEntier("\nEntrez le nombre total de votes : ");
		return genererTabEntier(nbElements, NB_CANDIDATS_MIN, nbCandidats);
	}


	private static int[] compterVotes(int[] tabVotes, int nbCandidats) {
		int[] tabResultatsVotes = new int[nbCandidats];
	
		for(int i = 0; i < nbCandidats; ++i){
			for(int y = 0; y < tabVotes.length; y++){
				if(tabVotes[y] == (i + 1)){
					tabResultatsVotes[i]+=1;
				}
			}
		}
		
		return tabResultatsVotes;
	}
	private static int calculerProduitTabEntier(int[] tab) {
		int prodTableau = tab[0];
		for (int i = 1; i < tab.length; i++){
			prodTableau *= tab[i];
		}
		return prodTableau;
	}

	private static int compterValTabEntier(int[] tab, int valACompter) {
		int nbReq = 0;
		for(int i = 0; i < tab.length - 1; ++i){
			if(tab[i] == valACompter){
				nbReq ++;
			}
		}
		return nbReq;
	}

	private static void afficherTabEntier(String titreTableau,
			int[] tab) {
		System.out.println(titreTableau + "\n");
		for (int i = 0; i < (tab.length ); ++i){
			System.out.println(tab[i] + " ");
		}
		
	}

	private static int[] genererTabEntier(int nbElements, int borneInferieure, int borneSupperieure) {
		int[] tab = new int[nbElements];
		for(int i = 0; i < (nbElements - 1 ); ++i){
			tab[i] = genererNbHasard(borneInferieure, borneSupperieure);
		}
		return tab;
	}
	/*
	 *
	 */
	private static void genererTabEntierDifferents() {
		// Constantes.
		final int NB_ELEMENTS = 5;
		final int NB_MIN = 0;
		final int NB_MAX = 9;
		// Énoncés qui permettent d'initialiser un tableau
		// avec des nombres entiers aléatoires différents.
		int[] tab = new int[NB_ELEMENTS];
		boolean[] tabPresent= new boolean[NB_MAX + 1];
		int element;
		for ( int i = 0; i < tab.length; ++i ) {
			element = genererNbHasard( NB_MIN, NB_MAX ); // Entre 0 et 9.
			// Ici, element sert d'indice pour le tableau tabPresent.
			if ( !tabPresent[element] ) {
				// Pas présent. On peut l'ajouter.
				tab[i] = element;
				// Il est maintenant présent.
				tabPresent[element] = true;
			} else {
			--i; // Recommencer avec le même indice.
			}
		}
	}
	
	private static int[] genererTabParesse101(String questionVoulu) throws IOException{
		switch (questionVoulu){
		
		}
		int  nbElements = lireEntier("\nEntrez le nombre d'éléments du" + 
				" tableau : "), borneInferieure = lireEntier("\nEntrez la borne inférieure du" + 
				" tableau : "), borneSupperieure = lireEntier("\nEntrez la borne suppérieure du" + 
								" tableau : ");

		int[] tab = new int[nbElements] ;
		return tab = genererTabEntier(nbElements, borneInferieure, borneSupperieure);
	}
	
	private static int afficherMenuPrincipal(int nbExercises) 
			throws IOException {
		String menu = "\nEXERCISES SUR LES STRUCTURES RÉPÉTITIVES\n\n";
		for (int i = 1; i <= nbExercises; i++) {
			menu += ( i + "- Exercise " + i + "\n");
			if(i == nbExercises){
				menu += "0- Quitter\n";	
			}
		} 
		System.out.println(menu);
		
		return lireEntier("Entrer votre choix : ");
	}
	
	/*
	 * La méthode lireEntier() permet de lire un entier sans aucune validation.
	 *
	 * Paramètre : la question à afficher à l'utilisateur.
	 *
	 * Retourne : le nombre entier lu.
	 */

	private static int lireEntier( String question ) throws IOException {
		BufferedReader clavier = 
			new BufferedReader( new InputStreamReader( System.in ) );

		System.out.print( question );

		return Integer.parseInt( clavier.readLine() );
	}

	/*
	 * La méthode lireReel() permet de lire un réel sans aucune validation.
	 *
	 * Paramètre : la question à afficher à l'utilisateur.
	 *
	 * Retourne : le nombre réel lu.
	 */

	private static double lireReel( String question ) throws IOException {
		BufferedReader clavier = 
			new BufferedReader( new InputStreamReader( System.in ) );

		System.out.print( question );

		return Double.parseDouble( clavier.readLine() );
	}
	
	/*
	 * La méthode lireChaine() permet de lire une chaîne sans aucune 
	 * validation.
	 *
	 * Paramètre : la question à afficher à l'utilisateur.
	 *
	 * Retourne : la chaîne de caractères lue.
	 */
	
	private static String lireChaine( String question ) throws IOException {
		BufferedReader clavier =
			new BufferedReader( new InputStreamReader( System.in ) );
		
		System.out.print( question );
		
		return clavier.readLine();
	}

	/*
	 * La méthode lireCaractere() permet de lire un caractère sans aucune
	 * validation.
	 *
	 * Paramètre : la question à afficher à l'utilisateur.
	 *
	 * Retourne : le caractère lu.
	 */
	
	private static char lireCaractere( String question ) throws IOException {
		BufferedReader clavier = 
			new BufferedReader( new InputStreamReader( System.in ) );
		
		System.out.print( question );
		
		return clavier.readLine().charAt( 0 );
	}
	
	/*
	 * La méthode formaterNb() permet de formater un nombre dans 
	 * le format 9999,99.
	 *
	 * Paramètres : Le nombre à formater et le nombre de décimales
	 *				à mettre après la virgule.
	 *
	 * Retourne : la chaîne de caractères contenant le nombre formaté.
	 */
	
	private static String formaterNb( double nb, int dec ) {
		NumberFormat formatNb = NumberFormat.getNumberInstance();
		
		formatNb.setMinimumIntegerDigits( 1 );
		formatNb.setMinimumFractionDigits( dec );
		formatNb.setMaximumFractionDigits( dec );
		
		return formatNb.format( nb );
	}
	
	/*
	 * La méthode formaterMonetaire() permet de formater un 
	 * nombre dans le format 9 999,99 $.
	 *
	 * Paramètres : le nombre à formater et le nombre de décimales
	 *				à mettre après la virgule.
	 *
	 * Retourne : la chaîne de caractères contenant le nombre formaté.
	 */
	
	private static String formaterMonetaire( double nb, int dec ) {
		NumberFormat formatNb = NumberFormat.getCurrencyInstance();
	
		formatNb.setMinimumIntegerDigits( 1 );
		formatNb.setMinimumFractionDigits( dec );
		formatNb.setMaximumFractionDigits( dec );
		
		return formatNb.format(nb);
	}
	
	/*
	 * La méthode formaterPourcentage() permet de formater un 
	 * nombre dans le format 9 999,99 %.
	 *
	 * Paramètres : le nombre à formater et le nombre de décimales
	 *				à mettre après la virgule.
	 *
	 * Retourne : la chaîne de caractères contenant le nombre formaté.
	 */
	
	private static String formaterPourcentage( double nb, int dec ) {
		NumberFormat formatNb = NumberFormat.getPercentInstance();
		
		formatNb.setMinimumIntegerDigits( 1 );
		formatNb.setMinimumFractionDigits( dec );
		formatNb.setMaximumFractionDigits( dec );
		
		return formatNb.format( nb );
	}

	/*
	 * La méthode genererNbHasard() permet de générer un nombre entier 
	 * aléatoire entre une borne inférieure et une borne supérieure. 
	 * Ne fonctionne qu'avec des entiers plus grand ou égal à 0.
	 *
	 * Paramètres : la borne inférieure et la borne supérieure. Aucune
	 *				validation, la borne inférieure doit être plus
	 *				petite ou égale à la borne supérieure.
	 *
	 * Retourne : un entier au hasard entre les deux bornes inclusivement.
	 */
	
	private static int genererNbHasard( int min, int max ) {
		return (int) ( ( Math.random() * ( max - min + 1 ) ) + min );
	}
	
	/*
	* La méthode lireEntree() permet d'afficher une question et
	* de lire seulement la touche Entrée du clavier.
	*
	* Paramètre : la question à afficher.
	*
	* Retourne : rien.
	*/
	private static void lireEntree( String question ) throws IOException {
		BufferedReader clavier =
					new BufferedReader( new InputStreamReader( System.in ) );
		String chaine;
		boolean valide;
		int lgChaine;
		do {
			valide = true;
			System.out.print( question );
			chaine = clavier.readLine();
			lgChaine = chaine.length();
			// Erreur si la chaîne lue n'est pas vide.
			if ( lgChaine > 0 ) {
			System.out.println( "\nErreur, appuyez sur la touche " +
			"Entrée seulement." );
			valide = false;
			}
		} while ( !valide );
	}
	
	/*
	 * La méthode lireEntierValide() permet d'afficher une question et de lire
	 * un nombre entier qui fait partie d'un intervalle.
	 * 
	 * Paramètres : la question à afficher à l'utilisateur, le nombre minimum
	 *              et le nombre maximum.
	 * 
	 * Retourne : le nombre entier lu.
	 * 
	 */
	
	private static int lireEntierValide( String question, int min, int max )
			throws IOException {

		boolean valide;
		int nombreLu;

		do {
			valide = true;

			nombreLu = lireEntier( question );

			// Erreur si le nombre lu n'est pas entre min et max.
		
			if ( nombreLu < min || nombreLu > max ) {
				System.out.println( "\nErreur, entrez un nombre entier " +
									"entre " + min + " et " + max );
				valide = false;
			}
		} while ( !valide );

		return nombreLu;
	}
	
	/*
	 * La méthode lireEntierSuppZero() permet d'afficher une question et de lire
	 * un nombre entier qui est suppérieur à zéro.
	 * 
	 * Paramètres : la question à afficher à l'utilisateur
	 * 
	 * Retourne : le nombre entier lu.
	 * 
	 */
	
	private static int lireEntierSuppZero( String question) throws IOException {
		final int MIN = 0;
		boolean valide;
		int nombreLu;
		
		do {
			valide = true;

			nombreLu = lireEntier( question );

			// Erreur si le nombre lu n'est pas entre min et max.
		
			if ( nombreLu < MIN) {
				System.out.println( "\nErreur, entrez un nombre entier " +
									"suppérieur à " + MIN );
				valide = false;
			}
		} while ( !valide );

		return nombreLu;
	}
}