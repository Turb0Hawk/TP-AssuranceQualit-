/**
 * Auteurs : David et Soti
 * Fichier : Sudoku.java
 * Cours   : 420-3A6-MO (TP5, Expressions arithmétiques et Sudoku)
 * Date    : 1 novembre 2018
 */

// Packages.
import java.util.*;

import com.sun.xml.internal.bind.v2.runtime.reflect.ListIterator;

/**
 * La classe Sudoku contient les informations et les méthodes qui permettent de
 * construire et de résoudre une grille de sudoku.
 */

public class Sudoku {
	// Constantes de la classe Sudoku.

	private static final String TITRE_INITIAL = "\nGrille initiale";

	private static final String TITRE_FINAL = "\nGrille finale";

	// Champs d'instance privés de la classe Sudoku.

	// La grille de sudoku.
	private int[][] grille;

	// Les dimensions de la grille et d'un bloc de la grille.
	private int dimGrille;
	private int dimBloc;

	// Tableaux pour vérifier si un chiffre est présent sur une ligne,
	// sur une colonne et sur un bloc.

	private boolean[][] presentLigne;
	private boolean[][] presentColonne;
	private boolean[][] presentBloc;

	// La liste des positions à remplir.

	private LinkedList<PositionGrilleSudoku> listePositions;

	/**
	 * Constructeur qui permet de construire une grille de sudoku avec le
	 * tableau reçu en paramètre.
	 * 
	 * Il permet d'initialiser la grille, la dimension de la grille et la
	 * dimension d'un bloc de la grille.
	 * 
	 * @param grille
	 *            Le tableau à deux dimensions de nombres entiers contenant les
	 *            données de la grille initiale de sudoku.
	 */

	public Sudoku( int[][] grille ) {

		/**
		 * 
		 * Avant de commencer à compléter cette classe, consulter les pages 5 à
		 * 11 de l'énoncé du TP5.
		 * 
		 * Le champ d'instance qui représente la grille doit pointer au même
		 * endroit que la grille reçue en paramètre.
		 * 
		 * Le champ d'instance qui représente la dimension de la grille doit
		 * contenir le nombre de lignes de la grille.
		 * 
		 * Le champ d'instance qui représente la dimension d'un bloc de la
		 * grille doit contenir la racine carrée (Math.sqrt()) de la dimension
		 * de la grille. Le résultat doit être converti en int.
		 */
		this.grille = grille;
		this.dimGrille = grille[0].length;
		this.dimBloc = (int) Math.sqrt( this.dimGrille );
	}

	/**
	 * Méthode qui permet de trouver et d'afficher la solution de la grille de
	 * sudoku. Elle permet d'afficher la grille initiale, d'initialiser les
	 * tableaux des présences des chiffres, d'initialiser la liste des positions
	 * à remplir, de lancer la résolution de la grille et d'afficher la grille
	 * finale.
	 */

	public void afficherSolution() {

		/**
		 * 
		 * Vous devez exécuter la méthode privée qui affiche la grille avec le
		 * titre TITRE_INITIAL pour afficher la grille initiale.
		 * 
		 * Vous devez exécuter la méthode privée qui permet d'initialiser les
		 * tableaux des présences des chiffres.
		 * 
		 * Vous devez exécuter la méthode privée qui permet de créer la liste
		 * des positions à remplir. La liste se trouvera dans le champ
		 * d'instance listePositions.
		 * 
		 * Vous devez créer un itérateur de la liste des positions. Voir en bas
		 * de la page 31 du document 4 (juste la ligne qui crée l'itérateur).
		 * 
		 * Vous devez exécuter la méthode privée qui permet de résoudre le
		 * sudoku. Le retour de cette méthode n'est pas considéré ici.
		 * 
		 * Vous devez vider la liste des positions avec la méthode appropriée de
		 * la liste.
		 * 
		 * Vous devez exécuter la méthode privée qui affiche la grille avec le
		 * titre TITRE_FINAL pour afficher la grille finale.
		 */
		afficherGrille( TITRE_INITIAL );
		initialiserTableauxPresences();
		creerListePositions();
		ListIterator<PositionGrilleSudoku> iterateurTemp = (ListIterator<PositionGrilleSudoku>) this.listePositions
				.listIterator();
		resolutionSudoku( iterateurTemp );
		listePositions.clear();
		afficherGrille( TITRE_FINAL );
	}

	/**
	 * Méthode qui permet de déterminer à quel bloc appartient une position de
	 * la grille.
	 * 
	 * @param ligne
	 *            La coordonnée ligne de la position.
	 * @param colonne
	 *            La coordonnée colonne de la position.
	 * 
	 * @return Le numéro du bloc de la position.
	 */

	private int noBloc( int ligne, int colonne ) {

		return this.dimBloc * ( ligne / this.dimBloc ) + ( colonne / this.dimBloc );
	}

	/**
	 * Méthode qui permet de marquer la présence d'un chiffre sur une ligne, sur
	 * une colonne et sur un bloc.
	 * 
	 * @param ligne
	 *            La ligne.
	 * @param colonne
	 *            La colonne.
	 * @param chiffre
	 *            Le chiffre.
	 * @param presence
	 *            true pour présent et false pour pas présent.
	 */

	private void marquerPresenceChiffre( int ligne, int colonne, int chiffre, boolean presence ) {

		presentLigne[ligne][chiffre] = presence;
		presentColonne[colonne][chiffre] = presence;
		presentBloc[this.noBloc( ligne, colonne )][chiffre] = presence;
	}

	/**
	 * Méthode qui permet d'initialiser les tableaux des présences des chiffres.
	 * Les chiffres qui ne sont pas présents sont marqués par le booléen false.
	 * Les chiffres déjà présents sont marqués par le booléen true. Cette façon
	 * de faire permet de rendre l'algorithme plus optimal. Un accès direct
	 * permettra de vérifier la présence d'un chiffre.
	 */

	private void initialiserTableauxPresences() {

		// Les tableaux seront initialisés à false après la création de ceux-ci.

		presentLigne = new boolean[this.dimGrille][this.dimGrille];
		presentColonne = new boolean[this.dimGrille][this.dimGrille];
		presentBloc = new boolean[this.dimGrille][this.dimGrille];

		// Marquer les chiffres présents.

		/**
		 * TODO Much jenk
		 * 
		 * Pour chaque case de la grille, si le chiffre de la case n'est pas
		 * zéro, vous devez exécuter la méthode qui permet de marquer la
		 * présence du chiffre. Ici, le paramètre chiffre doit contenir (chiffre
		 * - 1).
		 * 
		 * Voir l'utilité de ces tableaux, sur les pages 8 à 10 de l'énoncé du
		 * TP5.
		 */
		for ( int ligne = 0; ligne < this.dimGrille; ++ligne ) {
			for ( int colonne = 0; colonne < this.dimGrille; ++colonne ) {
				if ( grille[ligne][colonne] != 0 ) {
					marquerPresenceChiffre( ligne, colonne, grille[ligne][colonne] - 1, true );
				}
			}
		}

	}

	/**
	 * Méthode qui vérifie la présence d'un chiffre sur une ligne, sur une
	 * colonne et sur un bloc.
	 * 
	 * @param ligne
	 *            La ligne.
	 * @param colonne
	 *            La colonne.
	 * @param chiffre
	 *            Le chiffre.
	 * 
	 * @return true si le chiffre est présent et false dans la cas contraire.
	 */

	private boolean chiffrePresent( int ligne, int colonne, int chiffre ) {

		// boolean present = true;

		/**
		 * 
		 * SI ( le chiffre n'est pas présent dans les 3 tableaux suivants :
		 * 
		 * ....presentLigne à l'intersection ligne, chiffre,
		 * 
		 * ....presentColonne à l'intersection colonne, chiffre,
		 * 
		 * ....presentBloc à l'intersection this.noBloc(ligne, colonne), chiffre
		 * ) ALORS
		 * 
		 * ........le chiffre n'est pas présent.
		 * 
		 * FIN SI
		 */
		/*
		 * if(!presentLigne[ligne][chiffre] && !presentColonne[colonne][chiffre]
		 * && !presentBloc[this.noBloc(ligne, colonne)][chiffre]) { present =
		 * false; }
		 */
		return ( !presentLigne[ligne][chiffre] && !presentColonne[colonne][chiffre]
				&& !presentBloc[this.noBloc( ligne, colonne )][chiffre] );
	}

	/**
	 * Méthode qui calcule le nombre de valeurs possibles pour une position à
	 * remplir.
	 * 
	 * @param ligne
	 *            La coordonnée ligne de la position.
	 * @param colonne
	 *            La coordonnée colonne de la position.
	 * 
	 * @return Le nombre de valeurs possibles pour la position.
	 */

	private int calculerNbValeursPossibles( int ligne, int colonne ) {

		int nbValeurs = 0;

		// Si un chiffre n'est pas déjà sur une ligne, sur une colonne et
		// sur un bloc, alors on le compte comme une possibilté.

		/**
		 * 
		 * POUR ( chaque chiffre de 0 à < this.dimGrille ) FAIRE
		 * 
		 * ....SI ( le chiffre n'est pas présent, exécution de la méthode
		 * chiffrePresent ) ALORS
		 * 
		 * ............Ajouter 1 à nbValeurs.
		 * 
		 * ....FIN SI
		 * 
		 * FIN POUR
		 */
		for ( int chiffre = 0; chiffre < this.dimGrille; ++chiffre ) {
			if ( !chiffrePresent( ligne, colonne, chiffre ) ) {
				nbValeurs++;
			}
		}

		return nbValeurs;
	}

	/**
	 * Méthode qui permet de créer la liste des positions à remplir. La liste
	 * sera ensuite triée en ordre des nb. de valeurs possibles. L'exploration
	 * des possibilités sera minimisée et l'algorithme sera alors plus optimal.
	 */

	private void creerListePositions() {

		/**
		 * 
		 * Vous devez créer la liste des positions à remplir (champ d'instance
		 * listePositions). Au début, la liste est vide.
		 * 
		 * Pour chaque case de la grille, si la valeur de la case est zéro, vous
		 * devez effectuer les opérations suivantes :
		 * 
		 * ....Exécuter la méthode qui permet de calculer le nombre de valeurs
		 * 
		 * ....possibles pour cette case.
		 * 
		 * ....Créer un objet de type PositionGrilleSudoku avec les valeurs
		 * 
		 * ....appropriées.
		 * 
		 * ....Ajouter cet objet à la liste des positions.
		 * 
		 * Fin du traitement pour chaque case de la grille.
		 * 
		 * Vous devez par la suite, trier la liste des positions en ordre
		 * croissant des nb. de valeurs possibles. Pour ce faire, dans la classe
		 * Collections, il y a une méthode statique sort() qui permet de faire
		 * le tri de la liste que vous lui envoyée en paramètre. La méthode
		 * sort() se sert de la méthode compareTo() de l'objet. Voir la méthode
		 * compareTo() dans la classe PositionGrilleSudoku.
		 * 
		 * Voir l'utilité de la liste des positions, sur la page 10 de l'énoncé
		 * du TP5.
		 */

		this.listePositions = new LinkedList<PositionGrilleSudoku>();
		for ( int ligne = 0; ligne < this.dimGrille; ++ligne ) {
			for ( int colonne = 0; colonne < this.dimGrille; ++colonne ) {
				int nbValeursPossibles = calculerNbValeursPossibles( ligne, colonne );
				PositionGrilleSudoku posTemp = new PositionGrilleSudoku( ligne, colonne, nbValeursPossibles );
				listePositions.add( posTemp );
			}
		}
		Collections.sort( listePositions );
	}

	/**
	 * Méthode qui permet d'afficher une ligne selon la dimension de la grille.
	 */

	private void afficherLigne() {

		for ( int i = 1; i <= this.dimGrille; i++ ) {
			System.out.print( "--" );
		}

		System.out.println( "-" );
	}

	/**
	 * Méthode qui permet d'afficher la grille de sudoku.
	 * 
	 * @param titre
	 *            Le titre à afficher avant la grille.
	 */

	private void afficherGrille( String titre ) {

		System.out.println( titre );

		afficherLigne();

		for ( int li = 0; li < this.dimGrille; ++li ) {

			System.out.print( "|" );

			for ( int col = 0; col < this.dimGrille; ++col ) {

				System.out.print( ( grille[li][col] == 0 ? " " : grille[li][col] )
						+ ( ( col + 1 ) % this.dimBloc != 0 ? " " : "|" ) );
			}

			System.out.println();

			if ( ( li + 1 ) % this.dimBloc == 0 ) {

				afficherLigne();
			}
		}
	}

	/**
	 * Méthode récursive qui permet de résoudre une grille de sudoku. Les
	 * positions à remplir de la grille sont remplies au fur et à mesure. Une
	 * vérification constante est faite pour s'assurer que la grille reste
	 * toujours valide. Si une impasse survient, il ne sert à rien de continuer
	 * et un retour en arrière permet d'éviter de continuer une exploration
	 * inutile (backtracking).
	 * 
	 * @param iterateur
	 *            L'itérateur de la liste de la position courante à remplir.
	 * 
	 * @return true si la grille est valide et false dans le cas contraire.
	 */

	private boolean resolutionSudoku( ListIterator<PositionGrilleSudoku> iterateur ) {

		boolean estValide = false;

		/**
		 * TODO (À COMPLÉTER).
		 * 
		 * Programmer l'algorithme qui se trouve sur la page 11 de l'énoncé du
		 * TP5.
		 */

		if ( !iterateur.hasNext() ) {
			estValide = true;
		} else {
			PositionGrilleSudoku pos = (PositionGrilleSudoku) iterateur.next();
			int ligne = pos.getLigne(), colonne = pos.getColonne();
			boolean mauvaisChoix = false;
			for ( int chiffre = 0; chiffre < dimGrille && mauvaisChoix; ++chiffre ) {
				if ( chiffrePresent( ligne, colonne, chiffre ) ) {
					grille[ligne][colonne] = ( chiffre + 1 );
					marquerPresenceChiffre( ligne, colonne, chiffre, true );
					if ( resolutionSudoku( iterateur ) ) {
						estValide = true;
						boolean bonChoix = true;
					} else {
						grille[ligne][colonne] = 0;
						marquerPresenceChiffre( ligne, colonne, chiffre, false );
					}
				}
			}
			if ( mauvaisChoix ) {
				estValide = false;
				/*
				 * Récupérer la position précédente. Utiliser la méthode
				 * previous() de l'itérateur.
				 */
				pos = (PositionGrilleSudoku) iterateur.previous();
			}
		}
		return estValide;
	}
}
